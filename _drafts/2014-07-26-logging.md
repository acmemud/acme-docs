---
published: false
---

So I made I a project plan this week. Well not so much a project plan as a bunch of issues that are marked as either release 0.1 or 0.2. But I have a list, so that's something. Working my way from top to bottom in order of unsexiness, the next task after documentation generator is logging. Writing it was kind of a grind (as was most of the doc generator), but without a solution in place pretty much every piece of code is going to have to be ammended later when it eventually does come along. Logging is in _everything_. I suspect there are still a number of bugs to be found since I didn't really test everything, but whatever, that ubiquity just means we'll find em faster.

So here it is for your consideration. It's basically a simplified port of [log4j](http://logging.apache.org/log4j/2.x/) but it does have a couple MUD-specific bells and whistles to show off. 

# intro to log4j
So when I say log4j, I'm really talking about any number of logging libraries that use the same basic schematic. There are a number of them -- the ones I've bumped into are a wrapper API [slf4j](http://www.slf4j.org/), and Python's [logging library](https://docs.python.org/2/library/logging.html) to name a couple. If you're new to Java and are working out in the world, one of the first things yr gonna have to do is learn how log4j works. From what I can tell, pretty much _everyone_ uses something like it (even those embedded folks I bet). With that kind of adoption rate, I felt like it wasn't even worth the effort to consider some alternative solution. The interface is hopefully pretty intuitive even if you've never used one of those other loggers before. Here's the basic usage:
<pre><code><!--
-->object logger = LoggerFactory->get_logger(THISO);
logger->warn("it's a trick, get an %s", "axe");
</code></pre>
The message gets interpretted just like arguments to sprintf(). This one was just a warning, but you got like 6 log levels to choose from. Then you write this config file that specifies what exactly gets written, when, and where. That "THISO" argument up there is the "category", and configuration options are grouped by hierarchical category tree. This last part is important; it's one of the reasons I adopted the design that I did, but I need to explain the structure of the configuration files before I can get into that.

#### etc/logger.properties



That means the natural workflow is to think in terms of different source files when trying to zero in on a problem. Or to illustrate, I have a broad log configuration at the project's root with a default logfile and the log level ERROR

Can write a method like sprintf() now which lets us get rid of lots of is_enabled() tests. hate those tests, maybe a justification for aspect oriented programming.