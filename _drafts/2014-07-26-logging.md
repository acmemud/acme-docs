---
published: false
---

So I made I a project plan this week. Well not so much a project plan as a bunch of issues that are marked as either release 0.1 or 0.2. But I have a list, so that's something. Working my way from top to bottom in order of unsexiness, the next task after documentation generator is logging. Writing it was kind of a grind (as was most of the doc generator), but without a solution in place pretty much every piece of code is going to have to be ammended later when it eventually does come along. Logging is in _everything_. I suspect there are still a number of bugs to be found since I didn't really test everything, but whatever, that ubiquity just means we'll find em faster.

So here it is for your consideration. It's basically a simplified port of [log4j](http://logging.apache.org/log4j/2.x/) but it does have a couple MUD-specific bells and whistles to show off. 

#### intro to log4j
So when I say log4j, I'm really talking about any number of logging libraries that use the same basic schematic. There are a number of them -- the ones I've bumped into are a wrapper API [slf4j](http://www.slf4j.org/), and Python's [logging library](https://docs.python.org/2/library/logging.html) to name a couple. If you're new to Java and are working out in the world, one of the first things yr gonna have to do is learn how log4j works. From what I can tell, pretty much _everyone_ uses something like it (even those embedded folks I bet). With that kind of adoption rate, I felt like it wasn't even worth the effort to consider some alternative solution. The interface is hopefully pretty intuitive even if you've never used one of those other loggers before. The typical usage is something like this:
<code><pre><!--
-->object logger = LoggerFactory->get_logger(THISO);
logger->warn("it's a trick, get an %s", "axe");
</pre></code>

The message gets interpretted just like arguments to sprintf(). This one was just a warning, but you got like 6 log levels to choose from. Then you write this config file that specifies what exactly gets written, when, and where. That "THISO" argument up there is the "category", and configuration options are grouped by hierarchical category tree. This last part is important; it's one of the reasons I adopted the design that I did, but I need to explain the structure of the configuration files before I can get into that.

#### etc/logger.properties
The properties file is where things start to go off the rail a bit. A typical file looks like this:
<code>
  <caption>/private/eternal/etc/logger.properties</caption>
  <pre><!--
-->logger.output=f:log/eternal-city.log
logger.format=%d %p %l - %m
logger.level=ERROR
logger.library.output=f:log/eternal-city.log,c:thisp
logger.library.level=DEBUG<!--
--></pre>
</code>
Every line is of the format <pre>logger.&lt;category&gt;.prop=value</pre>, where category needs to match the category we passed to the get_logger() call above, and the prop is one of "output", "format", and "level".

In the example above, the first line does not specify a category, which means it applies to every category descended from and including the root category. The root category in this case is private.eternal, because the properties file is in the /private/eternal/etc folder. All paths and categories you specify in the config will be relative to this directory (minus the /etc part). The property that is being configured is the output property, which determines where the log message is written. This is comma-delimited list of target specifiers, where a target is specified as target type and a target spec, separated by a colon. If the target type is 'c', the target spec is interpreted as an object spec, and logger will tell_object() the message to the targets. If the target type is 'f', the target spec is interpreted as a filename (relative to the root) to which the message will be written.

The next line is the format string, which specifies exactly what information is written to the log (beyond just the message that was provided to the warn() call above. There's a lot going on here, so I'll save this for next section.

The third line sets the minimum level a log message needs to be in order to be logged. So the the first three lines altogether instruct the logger to: log every message of ERROR level or higher, logged from inside the /private/eternal directory and its descendents, to /private/eternal/log/eternal-city.log.

So one of the things I like about this model is that it massages your directory hierarchy to be complementary to your workflow. Take for instance the fourth and fifth lines above. Let's say that some code in the Eternal City library errored and the message was found in eternal-city.log, but did not provide enough information to remedy the problem. So someone has gone in and modified the logger.properties file to turn on logging for the all the DEBUG messages in the library. They also added a console output spec for thisp, because they plan on through the area and looking for the problem. This is all possible because the source code that makes up Eternal City has been thematically grouped by location, and the library has its own category.


Can write a method like sprintf() now which lets us get rid of lots of is_enabled() tests. hate those tests, maybe a justification for aspect oriented programming.